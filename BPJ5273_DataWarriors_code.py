# -*- coding: utf-8 -*-
"""BPJ5273_DataWarriors_code.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1W9FqCdr6gm9K4Gewr9Zzt1UvB4VXk3tv
"""

# install dtaidistance package by running this command <pip install dtaidistance>

#importing important libraries
import pandas as pd
import numpy as np
import math
from dtaidistance import dtw
import matplotlib.pyplot as plt
from datetime import datetime

#reading csv file and printing it
df=pd.read_csv('PricingData.csv')
df

#describing data to analyse it closely
df.describe()

#cleaning of rows contaning Seat Fare Type 2 value 0 beacuse they are anomalies & converting Seat Fare Type1 and 2 as strings
df=df[df["Seat Fare Type 2"]!='0']
df['Seat Fare Type 1']=df['Seat Fare Type 1'].astype(str)
df['Seat Fare Type 2']=df['Seat Fare Type 2'].astype(str)

#spliting Seat Fare 1 in four Subcategories front back middle and upper as Category11 and so on and assigning to new dataframe
price_cat11=[]
price_cat12=[]
price_cat13=[]
price_cat14=[]
for i in df["Seat Fare Type 1"]:
  price_list=i.split(',')
  price_list_int=[float(x) for x in price_list]
  if(len(price_list_int)==4):
    price_cat11.append(price_list_int[0])
    price_cat12.append(price_list_int[1])
    price_cat13.append(price_list_int[2])
    price_cat14.append(price_list_int[3])
  elif(len(price_list_int)==3):
    price_cat11.append(price_list_int[0])
    price_cat12.append(price_list_int[1])
    price_cat13.append(price_list_int[2])
    price_cat14.append(float('nan'))
  elif(len(price_list_int)==2):
    price_cat11.append(price_list_int[0])
    price_cat12.append(price_list_int[1])
    price_cat13.append(float('nan'))
    price_cat14.append(float('nan'))
  elif(len(price_list_int)==1):
    price_cat11.append(float('nan'))
    price_cat12.append(float('nan'))
    price_cat13.append(float('nan'))
    price_cat14.append(price_list_int[0])
  else:
    price_cat11.append(float('nan'))
    price_cat12.append(float('nan'))
    price_cat13.append(float('nan'))
    price_cat14.append(float('nan'))
df["Category11"]=price_cat11
df["Category12"]=price_cat12
df["Category13"]=price_cat13
df["Category14"]=price_cat14
df.drop('Seat Fare Type 1',
  axis='columns', inplace=True)

#spliting Seat Fare 2 in four Subcategories front back middle and upper as Category11 and so on and assigning to new dataframe
price_cat21=[]
price_cat22=[]
price_cat23=[]
price_cat24=[]
for i in df["Seat Fare Type 2"]: 
  price_list=i.split(',')
  price_list_int=[float(x) for x in price_list]
  if(len(price_list_int)==4):
    price_cat21.append(price_list_int[0])
    price_cat22.append(price_list_int[1])
    price_cat23.append(price_list_int[2])
    price_cat24.append(price_list_int[3])
  elif(len(price_list_int)==3):
    price_cat21.append(price_list_int[0])
    price_cat22.append(price_list_int[1])
    price_cat23.append(price_list_int[2])
    price_cat24.append(float('nan'))
  elif(len(price_list_int)==2):
    price_cat21.append(price_list_int[0])
    price_cat22.append(price_list_int[1])
    price_cat23.append(float('nan'))
    price_cat24.append(float('nan'))
  elif(len(price_list_int)==1):
    price_cat21.append(float('nan'))
    price_cat22.append(float('nan'))
    price_cat23.append(float('nan'))
    price_cat24.append(price_list_int[0])
  else:
    price_cat21.append(float('nan'))
    price_cat22.append(float('nan'))
    price_cat23.append(float('nan'))
    price_cat24.append(float('nan'))
df["Category21"]=price_cat21
df["Category22"]=price_cat22
df["Category23"]=price_cat23
df["Category24"]=price_cat24
df.drop('Seat Fare Type 2',
  axis='columns', inplace=True)
df

# now finding unique bus ids and collecting their prices at every instances in a list and assigning to data frame and nan value is where seat is not available
unique_bus_id=df["Bus"].unique()
data=pd.DataFrame(unique_bus_id,columns=['Unique_Bus_Service'])
data['Category11'] = data.apply(lambda x: [], axis=1)
data['Category12'] = data.apply(lambda x: [], axis=1)
data['Category13'] = data.apply(lambda x: [], axis=1)
data['Category14'] = data.apply(lambda x: [], axis=1)
data['Category21'] = data.apply(lambda x: [], axis=1)
data['Category22'] = data.apply(lambda x: [], axis=1)
data['Category23'] = data.apply(lambda x: [], axis=1)
data['Category24'] = data.apply(lambda x: [], axis=1)
data['Time_Record'] = data.apply(lambda x: [], axis=1)
for j in range(len(unique_bus_id)):
  p_cat11=[]
  p_cat12=[]
  p_cat13=[]
  p_cat14=[]
  p_cat21=[]
  p_cat22=[]
  p_cat23=[]
  p_cat24=[]
  t_cat1=[]
  t=[]
  for i in range(len(df["Bus"])):
    if(df.iloc[i]["Bus"]==unique_bus_id[j]):
      t.append(df.iloc[i]["RecordedAt"])
      p_cat11.append(df.iloc[i]["Category11"])
      p_cat12.append(df.iloc[i]["Category12"])
      p_cat13.append(df.iloc[i]["Category13"])
      p_cat14.append(df.iloc[i]["Category14"])
      p_cat21.append(df.iloc[i]["Category21"])
      p_cat22.append(df.iloc[i]["Category22"])
      p_cat23.append(df.iloc[i]["Category23"])
      p_cat24.append(df.iloc[i]["Category24"])
  data.at[j,"Category11"]=p_cat11 
  data.at[j,"Category12"]=p_cat12 
  data.at[j,"Category13"]=p_cat13 
  data.at[j,"Category14"]=p_cat14 
  data.at[j,"Category21"]=p_cat21 
  data.at[j,"Category22"]=p_cat22 
  data.at[j,"Category23"]=p_cat23 
  data.at[j,"Category24"]=p_cat24  
  data.at[j,"Time_Record"]=t

#displaying new dataframe with 78 unique bus ids and prices of different categories
data

# defining a sorting algo to sort the prices list in a ascending order with respect to date
def sorting_price_list(x,y):
  sorted_time_list=[]
  sorted_price_list=[] 
  for j in range(len(x)):
    sorted_time_list.append(min(x))
    sorted_price_list.append(y[x.index(min(x))])
    y.remove(y[x.index(min(x))])
    x.remove(min(x))
  return(sorted_time_list,sorted_price_list)

def remove_nan_value_formate_date(x):
  # sorting prices of according to date in ascending order and converting Recorded Time columns data as datetme format
  non_nan_list1=[]
  plt.figure(figsize=(15, 5))
  plt.xlabel("Date")
  plt.ylabel("Seat_Price_"+x)
  plt.title("Sample Time Series Plot")
  for i in range(len(data["Unique_Bus_Service"])):
    non_nan_price=[]
    non_nan_time=[]
    for (j,k) in zip(data.iloc[i][x],data.iloc[i]["Time_Record"]):
      if(not math.isnan(float(j))):
        non_nan_price.append(float(j))
        l=k.split(' ')[0].split('-')
        non_nan_time.append(datetime.fromisoformat(l[2]+'-'+l[1]+'-'+l[0]+' '+k.split(' ')[1]))
    (a,b)=sorting_price_list(non_nan_time,non_nan_price)
    non_nan_list1.append(b)
    # plotting time series graph comparing categorie11 prices of every buses 
    plt.plot(a,b,linewidth=1)
  return non_nan_list1

#plotting time series graph of category11 by calling function
non_nan_list1=remove_nan_value_formate_date("Category11")

#plotting time series graph of category12 by calling function
non_nan_list1=remove_nan_value_formate_date("Category12")

#plotting time series graph of category13 by calling function
non_nan_list1=remove_nan_value_formate_date("Category13")

#plotting time series graph of category14 by calling function
non_nan_list1=remove_nan_value_formate_date("Category14")

#plotting time series graph of category21 by calling function
non_nan_list1=remove_nan_value_formate_date("Category21")

#plotting time series graph of category22 by calling function
non_nan_list1=remove_nan_value_formate_date("Category22")

#plotting time series graph of category23 by calling function
non_nan_list1=remove_nan_value_formate_date("Category23")

#plotting time series graph of category24 by calling function
non_nan_list1=remove_nan_value_formate_date("Category24")

# this function computes dynamic time wrapping distance between time series of individual categories and -1 values are replaced by max_distance in the list +1000 if ma_value is defined else 1000
def dtw_comparison(pl):
  dtw_distance_comp=[]
  for i in range(len(pl)):
    dtw_distance_a=[]
    for j in range(len(pl)):
        if(i!=j):
            if(not math.isinf(dtw.distance(pl[i],pl[j]))):
              dtw_distance_a.append(dtw.distance(pl[i],pl[j]))
            else:
              dtw_distance_a.append(-1)

    maximum_sum_assumed=max(dtw_distance_a)
    if(maximum_sum_assumed==-1):
      maximum_sum_assumed=1000
    arr=np.asarray(dtw_distance_a)
    arr[ arr == -1] = maximum_sum_assumed         
    dtw_distance_comp.append(arr)
  return dtw_distance_comp

# function call to get dtw distance compared list
# note category21,category22,category23 are ignored as it contains very less data 
dtw_comparison_list1=dtw_comparison(non_nan_list1)
dtw_comparison_list2=dtw_comparison(non_nan_list2)
dtw_comparison_list3=dtw_comparison(non_nan_list3)
dtw_comparison_list4=dtw_comparison(non_nan_list4)
dtw_comparison_list8=dtw_comparison(non_nan_list8)

# summing up the distaces of categories and producing final sums list
final_dtw_sum_list=[]
for i in range(len(dtw_comparison_list1)):
  final_dtw_sum_list.append(np.sum(np.array([dtw_comparison_list1[i],dtw_comparison_list2[i],dtw_comparison_list3[i],dtw_comparison_list4[i],dtw_comparison_list8[i]]),axis=0))

# now we will find min value of dtw distance in list as a most closest follower bus
index_of_min_element=[]
min_distance_list=[]
for i in range(len(final_dtw_sum_list)):
  min_distance=min(final_dtw_sum_list[i])
  min_distance_list.append(min_distance)
  index_of_min_element.append(list(final_dtw_sum_list[i]).index(min_distance)+1)

# normalising the dtw distance with a formula (M-S(x,y))/M
normalisation_list=[]
max_value_distance=max(min_distance_list)
def dtw_distance_normalisation():
  for i in range(len(min_distance_list)):
    normalisation_list.append((max_value_distance-min_distance_list[i])/max_value_distance)
  return(normalisation_list)

#defining sigmoid to calculate confidence scores
def sigmoid(x):
  return (1/(1+np.exp(-x)))
confidence_scorelist=[]
normalised_list=dtw_distance_normalisation()
for i in range(len(normalised_list)):
  confidence_scorelist.append(sigmoid(normalised_list[i]))

# creating new data frame and setting the unique buses a 1st column and then follower and their confidence score
output_data=pd.DataFrame()
output_data["Bus_Service"]=data["Unique_Bus_Service"]
list_follower=[]
list_of_follows=[]
follows_confidence_list=[]
for i in range(len(data["Unique_Bus_Service"])):
  list_follower.append(data.iloc[index_of_min_element[i]]["Unique_Bus_Service"])
output_data["Is followed by"]=list_follower
output_data["Confidence Score (0 to 1)"]=confidence_scorelist
for i in range(len(output_data["Bus_Service"])):
  for j in range(len(output_data["Bus_Service"])):
    if(output_data.iloc[i]["Bus_Service"]==output_data.iloc[j]["Is followed by"]):
      list_of_follows.append(output_data.iloc[j]["Is followed by"])
      follows_confidence_list.append(output_data.iloc[j]["Confidence Score (0 to 1)"])
output_data["Follows"]=list_of_follows
output_data["Confidence Score (0 to 1) 2"]=follows_confidence_list
print(output_data)

output_data.to_csv('Output_Data.csv', sep='\t', index=False,header=True)